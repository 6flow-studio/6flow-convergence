---
source: tests/codegen_basic.rs
expression: main_ts.content
---
import { cre, ok, consensusIdenticalAggregation, getNetwork, Runner, type Runtime, type HTTPSendRequester, type CronTrigger } from "@chainlink/cre-sdk";
import { encodeFunctionData } from "viem";
import { z } from "zod";

const configSchema = z.object({
  schedule: z.string().default("TZ=UTC 0 */10 * * * *"),
  walletAddress: z.string(),
  tokenContractAddress: z.string(),
  mintAmount: z.string(),
});

type Config = z.infer<typeof configSchema>;

const fetch_http_1 = (sendRequester: HTTPSendRequester, config: any) => {
  const req = {
    url: `https://kyc-api.example.com/status/${config.walletAddress}`,
    method: "GET" as const,
    headers: {
      "Authorization": `Bearer ${config._authToken}`,
    },
    cacheSettings: {
      store: true,
      maxAge: { seconds: 60n },
    },
  };

  const resp = sendRequester.sendRequest(req).result();

  if (!ok(resp)) {
    throw new Error(`HTTP request failed with status: ${resp.statusCode}`);
  }

  return { statusCode: resp.statusCode, body: resp.body, headers: resp.headers };
};

const onCronTrigger = (runtime: Runtime<Config>, triggerData: CronTrigger): string => {
  const httpClient = new cre.capabilities.HTTPClient();
  const evmClient_eth_sepolia = new cre.capabilities.EVMClient(getNetwork({ chainFamily: "evm", chainSelectorName: "ethereum-testnet-sepolia", isTestnet: true })!.chainSelector.selector);

  // Fetch KYC status
  const _authSecret_http_1 = runtime.getSecret({ id: "KYC_API_KEY" }).result();
  const _fetchCfg_http_1 = {
    ...runtime.config,
    _authToken: _authSecret_http_1.value,
  };
  const step_http_1 = httpClient.sendRequest(runtime, fetch_http_1, consensusIdenticalAggregation())(_fetchCfg_http_1).result();
  // Parse KYC response
  const step_parse_1 = JSON.parse(Buffer.from(step_http_1.body, "base64").toString("utf-8"));
  // Check if KYC approved
  if (step_parse_1.isApproved === true) {
    // ABI encode mint call
    const step_mint_1___encode = {
      encoded: encodeFunctionData({
        abi: [{"name":"mint","type":"function","inputs":[{"name":"to","type":"address"},{"name":"amount","type":"uint256"}],"outputs":[],"stateMutability":"nonpayable"}],
        functionName: "mint",
        args: [runtime.config.walletAddress, runtime.config.mintAmount],
      }),
    };
    // Execute mint transaction
    const step_mint_1___write = evmClient_eth_sepolia.write(runtime, {
      receiverAddress: runtime.config.tokenContractAddress,
      gasLimit: BigInt(1000000),
      data: step_mint_1___encode.encoded,
    }).result();
    return "Minted successfully";
  } else {
    throw new Error("KYC not approved");
  }
};

const initWorkflow = (config: Config) => {
  return [
    cre.handler(
      new cre.capabilities.CronCapability().trigger({
        schedule: config.schedule,
      }),
      onCronTrigger,
    ),
  ];
};

export async function main() {
  const runner = await Runner.newRunner<Config>({ configSchema });
  await runner.run(initWorkflow);
}

main();
