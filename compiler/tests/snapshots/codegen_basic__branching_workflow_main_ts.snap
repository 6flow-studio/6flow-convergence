---
source: tests/codegen_basic.rs
expression: main_ts.content
---
import { cre, ok, consensusIdenticalAggregation, getNetwork, Runner, type Runtime, type HTTPSendRequester, type CronTrigger } from "@chainlink/cre-sdk";
import { z } from "zod";

const configSchema = z.object({
  schedule: z.string().default("TZ=UTC 0 */10 * * * *"),
  walletAddress: z.string(),
  receiverAddress: z.string(),
});

type Config = z.infer<typeof configSchema>;

const fetch_http_1 = (sendRequester: HTTPSendRequester, config: any) => {
  const req = {
    url: `https://kyc-api.example.com/status/${config.walletAddress}`,
    method: "GET" as const,
    headers: {
      "Authorization": `Bearer ${config._authToken}`,
    },
    cacheSettings: {
      store: true,
      maxAge: { seconds: 60n },
    },
  };

  const resp = sendRequester.sendRequest(req).result();

  if (!ok(resp)) {
    throw new Error(`HTTP request failed with status: ${resp.statusCode}`);
  }

  return { statusCode: resp.statusCode, body: resp.body, headers: resp.headers };
};

const onCronTrigger = (runtime: Runtime<Config>, triggerData: CronTrigger): string => {
  const httpClient = new cre.capabilities.HTTPClient();
  const evmClient_eth_sepolia = new cre.capabilities.EVMClient(getNetwork({ chainFamily: "evm", chainSelectorName: "ethereum-testnet-sepolia", isTestnet: true })!.chainSelector.selector);

  const __stringify = (v: unknown) => JSON.stringify(v, (_, x) => typeof x === "bigint" ? x.toString() : x);

  // Fetch status
  const _authSecret_http_1 = runtime.getSecret({ id: "KYC_API_KEY" }).result();
  const _fetchCfg_http_1 = {
    ...runtime.config,
    _authToken: _authSecret_http_1.value,
  };
  const step_http_1 = httpClient.sendRequest(runtime, fetch_http_1, consensusIdenticalAggregation())(_fetchCfg_http_1).result();
  runtime.log(`[Fetch status] ${__stringify(step_http_1)}`);
  // Parse response
  const step_parse_1 = JSON.parse(Buffer.from(step_http_1.body, "base64").toString("utf-8"));
  runtime.log(`[Parse response] ${__stringify(step_parse_1)}`);
  // Check if approved
  if (step_parse_1.isApproved === true) {
    // Write to contract
    const step_write_1 = evmClient_eth_sepolia.write(runtime, {
      receiverAddress: runtime.config.receiverAddress,
      gasLimit: BigInt(500000),
      data: step_parse_1.data,
    }).result();
    runtime.log(`[Write to contract] ${__stringify(step_write_1)}`);
    return "Minted successfully";
  } else {
    return "KYC not approved";
  }
};

const initWorkflow = (config: Config) => {
  return [
    cre.handler(
      new cre.capabilities.CronCapability().trigger({
        schedule: config.schedule,
      }),
      onCronTrigger,
    ),
  ];
};

export async function main() {
  const runner = await Runner.newRunner<Config>({ configSchema });
  await runner.run(initWorkflow);
}

main();
